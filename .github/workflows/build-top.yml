name: Build from AI Leaderboards page (scrape & merge JSON)

on:
  schedule:
    - cron: "40 5 * * *"     # tous les jours 05:40 UTC
  workflow_dispatch:

permissions:
  contents: write

jobs:
  scrape:
    runs-on: ubuntu-latest
    env:
      # 👉 METS ICI L’URL EXACTE DE TA PAGE "AI Leaderboards"
      LEADERBOARD_URL: https://llm-stats.com/
      # Mets à "true" pour committer un snapshot HTML si tu veux débug
      SAVE_SNAPSHOT: "true"

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Puppeteer
        run: |
          npm init -y
          npm i puppeteer@22

      - name: Write scraper
        run: |
          cat > scrape_leaderboards.mjs <<'JS'
          import fs from 'node:fs/promises';
          import puppeteer from 'puppeteer';

          const URL = process.env.LEADERBOARD_URL;
          const SAVE_SNAPSHOT = (process.env.SAVE_SNAPSHOT || '').toLowerCase() === 'true';

          const sleep = (ms)=> new Promise(r=>setTimeout(r,ms));

          // ---------- utils ----------
          function cleanLines(txt){
            return String(txt)
              .split(/\n+/)
              .map(s=>s.replace(/\s+/g,' ').trim())
              .filter(Boolean);
          }
          function fmtTokens(n){
            if (n >= 1_000_000) return `${(n/1_000_000).toFixed(1)}M tokens`;
            if (n >= 1_000)     return `${Math.round(n/1000)}K tokens`;
            return `${Math.round(n)} tokens`;
          }
          function toFloat(x){
            if (x == null) return null;
            const s = String(x).replace(/[, $%]/g,'').trim();
            if (!s || /^[\-–—]$/.test(s)) return null;
            const f = Number(s);
            return Number.isFinite(f) ? f : null;
          }

          // Récupère le bloc (innerText) d’une carte par son titre
          async function grabCardText(page, titleRegex){
            return page.evaluate((reSrc)=>{
              const re = new RegExp(reSrc, 'i');
              const headers = [...document.querySelectorAll('h1,h2,h3')];
              const h = headers.find(el => re.test(el.textContent.trim()));
              if (!h) return null;
              // remonte à un conteneur raisonnable
              let node = h;
              for (let i=0;i<5 && node && !/^(SECTION|DIV|ARTICLE)$/i.test(node.tagName); i++){
                node = node.parentElement;
              }
              node = node || h.parentElement;
              return node ? node.innerText : null;
            }, titleRegex.source);
          }

          // Découpe un bloc "carte" en 5 rangs, puis extrait nom + score/value
          function parseRankedBlock(blockText, mode){
            // mode: 'score' (Code/MMMU/GPQA) | 'value' (Context/Cheapest/Fastest)
            const L = cleanLines(blockText || '');
            if (!L.length) return [];

            // positions des rangs ("1", "2", ...)
            const rankIdx = [];
            for (let i=0;i<L.length;i++){
              if (/^[1-5]$/.test(L[i])) rankIdx.push(i);
            }
            if (!rankIdx.length){
              // fallback : lignes commençant par "1 " / "2 "…
              for (let i=0;i<L.length;i++){
                if (/^[1-5]\s/.test(L[i])) rankIdx.push(i);
              }
            }
            if (!rankIdx.length) return [];

            const rows = [];
            for (let r=0; r<rankIdx.length && rows.length<5; r++){
              const start = rankIdx[r];
              const end   = rankIdx[r+1] ?? L.length;
              // si la ligne contient "1 <name> ...": sépare-la d’abord
              let seg = L.slice(start, end);
              if (/^[1-5]\s+/.test(seg[0])) seg[0] = seg[0].replace(/^[1-5]\s+/, '');

              // name: première ligne avec du texte “alphnum”
              const name = seg.find(s => /[A-Za-z0-9]/.test(s)) || '';
              if (!name) continue;

              // score/value: cherche en partant de la fin
              let val = null;
              for (let k=seg.length-1; k>=0; k--){
                const s = seg[k];

                // % pour score (88.4)
                const mPct = s.match(/(\d{1,3}(?:\.\d+)?)(?:\s*%|$)/);
                // tokens / tokens/s
                const mTok = s.match(/([\d\.,]+(?:\s*[MK])?)\s*tokens(?:\/s)?/i);
                // prix $x / 1M tokens
                const mPer = s.match(/\$\s*([\d\.,]+)\s*\/\s*1M/i);

                if (mode==='score' && mPct){
                  val = Number(mPct[1]); break;
                }
                if (mode==='value' && (mTok || mPer)){
                  if (mTok){
                    // normaliser 10M -> "10.0M tokens" ou "639 tokens/s"
                    const raw = mTok[0];
                    const isPerSec = /tokens\/s/i.test(raw);
                    const numRaw = mTok[1].replace(/,/g,'').trim();
                    let num;
                    if (/m$/i.test(numRaw))      num = Number(numRaw.replace(/m/i,''))*1_000_000;
                    else if (/k$/i.test(numRaw)) num = Number(numRaw.replace(/k/i,''))*1_000;
                    else                          num = Number(numRaw);
                    val = isPerSec ? `${Math.round(num)} tokens/s` : fmtTokens(num);
                  }else{
                    val = `$${Number(mPer[1])} / 1M tokens`;
                  }
                  break;
                }
              }

              if (mode==='score' && val!=null) rows.push({name, score: val});
              if (mode==='value' && val)       rows.push({name, value: val});
            }
            return rows.slice(0,5);
          }

          (async ()=>{
            const browser = await puppeteer.launch({
              headless: 'new',
              args: ['--no-sandbox','--disable-setuid-sandbox']
            });
            const page = await browser.newPage();
            await page.setViewport({width: 1440, height: 1000});
            await page.goto(URL, {waitUntil: 'networkidle2', timeout: 90000});

            // Scroll pour charger toutes les cartes
            for (let i=0;i<12;i++){ await page.evaluate(()=>window.scrollBy(0, window.innerHeight)); await sleep(300); }

            // Snapshot HTML pour debug (optionnel)
            if (SAVE_SNAPSHOT){
              const html = await page.content();
              await fs.writeFile('leaderboard-snapshot.html', html, 'utf8');
            }

            // Titres tolérants
            const codeTxt  = await grabCardText(page, /(best\s+llm.*code|aider\s+polyglot)/i);
            const mmuTxt   = await grabCardText(page, /(best\s+multimodal\s+llm|mmmu\s+benchmark)/i);
            const gpqaTxt  = await grabCardText(page, /(best\s+llm.*knowledge|gpqa\s+benchmark)/i);
            const ctxTxt   = await grabCardText(page, /(longest\s+context|max\s+input\s+tokens)/i);
            const cheapTxt = await grabCardText(page, /(cheapest\s+api\s+provider|input\s+cost|maverick\s+input\s+cost)/i);
            const fastTxt  = await grabCardText(page, /(fastest\s+api\s+provider|throughput|maverick\s+throughput)/i);

            await browser.close();

            const code   = parseRankedBlock(codeTxt,  'score');
            const multi  = parseRankedBlock(mmuTxt,   'score');
            const know   = parseRankedBlock(gpqaTxt,  'score');
            const ctx    = parseRankedBlock(ctxTxt,   'value');
            const cheap  = parseRankedBlock(cheapTxt, 'value');
            const fast   = parseRankedBlock(fastTxt,  'value');

            // Fusion avec JSON existant
            let existing = {};
            try { existing = JSON.parse(await fs.readFile('top-leaderboards.json','utf8')); } catch {}
            const merged = {
              code:            code.length  ? code  : (existing.code || []),
              multimodal:      multi.length ? multi : (existing.multimodal || []),
              knowledge:       know.length  ? know  : (existing.knowledge || []),
              longest_context: ctx.length   ? ctx   : (existing.longest_context || []),
              cheapest:        cheap.length ? cheap : (existing.cheapest || []),
              fastest:         fast.length  ? fast  : (existing.fastest || []),
            };

            await fs.writeFile('top-leaderboards.json', JSON.stringify(merged, null, 2), 'utf8');
            console.log('Done. Counts:', Object.fromEntries(Object.entries(merged).map(([k,v])=>[k, Array.isArray(v)? v.length : 0])));
          })().catch(e=>{ console.error(e); process.exit(1); });
          JS

      - name: Run scraper
        run: node scrape_leaderboards.mjs

      - name: Commit & push if changed (and optional snapshot)
        run: |
          echo "Changed files (before):"; git status --porcelain || true
          if ! git diff --quiet -- top-leaderboards.json leaderboard-snapshot.html; then
            git config user.name  "leaderboards-bot"
            git config user.email "actions@github.com"
            git add top-leaderboards.json
            if [ -f leaderboard-snapshot.html ]; then git add leaderboard-snapshot.html; fi
            git commit -m "chore: update from AI Leaderboards page"
            git push
          else
            echo "No changes"
          fi
