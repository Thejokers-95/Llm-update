name: Build from llm-stats.com (scrape & merge JSON)

on:
  schedule:
    - cron: "30 5 * * *"   # tous les jours à 05:30 UTC
  workflow_dispatch:

permissions:
  contents: write

jobs:
  scrape:
    runs-on: ubuntu-latest
    env:
      # Tu peux remplacer par une URL filtrée (ex: vue Multimodal/Open Models). L’outil scrolle pour charger les lignes.
      LLM_STATS_URL: https://llm-stats.com/

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Puppeteer
        run: |
          npm init -y
          npm i puppeteer@22

      - name: Write scraper
        run: |
          cat > scrape_llmstats.mjs <<'JS'
          import fs from 'node:fs/promises';
          import puppeteer from 'puppeteer';

          const URL = process.env.LLM_STATS_URL || 'https://llm-stats.com/';

          const sleep = (ms)=> new Promise(r=>setTimeout(r,ms));

          function toFloat(x){
            if (x === null || x === undefined) return null;
            const s = String(x).replace(/[, $%]/g,'').trim();
            if (!s || s === '-' || s === '—' || s === '–') return null;
            const f = Number(s);
            return Number.isFinite(f) ? f : null;
          }
          function parseTokensCell(x){
            if (x === null || x === undefined) return null;
            let s = String(x).toLowerCase().replace(/[, ]/g,'').replace('tokens','');
            if (!s || s==='-'||s==='—'||s==='–') return null;
            // 1_048_576, 1048576
            if (/^\d+$/.test(s)) return Number(s);
            // 2.1m / 256k
            let m = s.match(/^([\d.]+)m$/); if (m) return Math.round(Number(m[1])*1_000_000);
            m = s.match(/^([\d.]+)k$/);     if (m) return Math.round(Number(m[1])*1_000);
            return null;
          }
          function fmtTokens(n){
            if (n >= 1_000_000) return `${(n/1_000_000).toFixed(1)}M tokens`;
            if (n >= 1_000)     return `${Math.round(n/1000)}K tokens`;
            return `${Math.round(n)} tokens`;
          }

          // Map les en-têtes → clefs canoniques
          function canonicalize(th){
            const k = th.toLowerCase().replace(/\s+/g,' ').trim();
            if (/^organization|vendor|provider|company$/.test(k)) return 'org';
            if (/^model|name$/.test(k)) return 'model';
            if (/input.*context|context.*length/.test(k)) return 'context';
            if (/input.*\$.*m|input.*m.*price|price.*per.*1m|price.*\/.*1m/.test(k)) return 'input_per_m';
            if (/^gpqa/.test(k)) return 'gpqa';
            if (/^mmmu|multimodal|vision$/.test(k)) return 'mmmu';
            if (/^mmlu$/.test(k)) return 'mmlu';
            return null;
          }

          // Essaie d’extraire un tableau <table>, sinon un tableau ARIA
          async function extractRows(page){
            // Attends que quelque chose ressemblant à des lignes apparaisse
            await page.waitForSelector('table, [role="table"]', {timeout: 30000}).catch(()=>{});
            // Scroll pour charger lazy/infinite rows
            for (let i=0;i<12;i++){
              await page.evaluate(()=>window.scrollBy(0, window.innerHeight));
              await sleep(600);
            }
            // 1) <table>
            const hasTable = await page.$('table');
            if (hasTable){
              return page.evaluate(()=>{
                const tbl = document.querySelector('table');
                const head = [...tbl.querySelectorAll('thead th')].map(th=>th.innerText.trim());
                const bodyRows = [...tbl.querySelectorAll('tbody tr')];
                const rows = bodyRows.map(tr => [...tr.querySelectorAll('td')].map(td=>td.innerText.trim()));
                return {head, rows};
              });
            }
            // 2) ARIA table fallback
            const hasAria = await page.$('[role="table"]');
            if (hasAria){
              return page.evaluate(()=>{
                const table = document.querySelector('[role="table"]');
                const head = [...table.querySelectorAll('[role="columnheader"]')].map(el=>el.innerText.trim());
                const rowEls = [...table.querySelectorAll('[role="row"]')].filter(r => r.querySelector('[role="cell"]'));
                const rows = rowEls.map(r => [...r.querySelectorAll('[role="cell"]')].map(td=>td.innerText.trim()));
                return {head, rows};
              });
            }
            return {head:[], rows:[]};
          }

          // Calcule tops à partir des objets [{org, model, context, input_per_m, gpqa, mmmu, mmlu}]
          function computeTops(items){
            const knowledge = items
              .filter(r => r.gpqa != null)
              .sort((a,b)=>b.gpqa-a.gpqa)
              .slice(0,5)
              .map(r => ({name: r.model, score: r.gpqa}));

            // Multimodal = MMMU prioritaire, sinon MMLU
            const multi = items
              .map(r => ({model:r.model, score: r.mmmu ?? r.mmlu}))
              .filter(r => r.score != null)
              .sort((a,b)=>b.score-a.score)
              .slice(0,5)
              .map(r => ({name: r.model, score: r.score}));

            // Longest context
            const ctx = items
              .filter(r => r.context_tokens != null)
              .sort((a,b)=>b.context_tokens - a.context_tokens)
              .slice(0,5)
              .map(r => ({name: r.model, value: fmtTokens(r.context_tokens)}));

            // Cheapest provider = min Input $/M par org
            const minByOrg = new Map();
            for (const r of items){
              if (r.org && r.input_per_m != null){
                const prev = minByOrg.get(r.org);
                minByOrg.set(r.org, prev==null? r.input_per_m : Math.min(prev, r.input_per_m));
              }
            }
            const cheapest = [...minByOrg.entries()]
              .map(([org,val]) => ({name: org, value: `$${val.toFixed(2)} / 1M tokens`}))
              .sort((a,b)=>parseFloat(a.value.slice(1)) - parseFloat(b.value.slice(1)))
              .slice(0,5);

            return {knowledge, multimodal: multi, longest_context: ctx, cheapest};
          }

          (async ()=>{
            const browser = await puppeteer.launch({
              headless: 'new',
              args: ['--no-sandbox','--disable-setuid-sandbox']
            });
            const page = await browser.newPage();
            await page.setViewport({width: 1400, height: 900});
            await page.goto(URL, {waitUntil: 'networkidle2', timeout: 60000});

            const {head, rows} = await extractRows(page);
            await browser.close();

            if (!head.length || !rows.length){
              console.log('No table detected.');
              process.exit(0);
            }

            // Map colonnes
            const map = {};
            head.forEach((h, idx)=>{
              const key = canonicalize(h);
              if (key) map[key] = idx;
            });

            const items = rows.map(cells=>{
              const get = (k)=> (map[k] != null ? cells[map[k]] : null);
              const org   = get('org')   ?? '';
              const model = get('model') ?? '';
              const ctx   = get('context');
              const inpm  = get('input_per_m');
              const gpqa  = get('gpqa');
              const mmmu  = get('mmmu');
              const mmlu  = get('mmlu');

              const obj = {
                org: String(org).trim(),
                model: String(model).trim(),
                context_tokens: parseTokensCell(ctx),
                input_per_m: toFloat(inpm),
                gpqa: toFloat(gpqa),
                mmmu: toFloat(mmmu),
                mmlu: toFloat(mmlu),
              };
              return obj;
            }).filter(r => r.model);

            const tops = computeTops(items);

            // Fusion avec JSON existant pour conserver "code" et "fastest"
            let existing = {};
            try { existing = JSON.parse(await fs.readFile('top-leaderboards.json','utf8')); } catch {}
            const merged = {
              code: existing?.code ?? [],
              multimodal: tops.multimodal,
              knowledge: tops.knowledge,
              longest_context: tops.longest_context,
              cheapest: tops.cheapest,
              fastest: existing?.fastest ?? []
            };

            await fs.writeFile('top-leaderboards.json', JSON.stringify(merged, null, 2), 'utf8');
            console.log('Done. Counts:', Object.fromEntries(Object.entries(merged).map(([k,v])=>[k, Array.isArray(v)? v.length : 0])));
          })().catch(e=>{ console.error(e); process.exit(1); });
          JS

      - name: Run scraper
        run: node scrape_llmstats.mjs

      - name: Commit & push if changed
        run: |
          echo "Changed files (before):"; git status --porcelain || true
          if ! git diff --quiet -- top-leaderboards.json; then
            git config user.name  "leaderboards-bot"
            git config user.email "actions@github.com"
            git add top-leaderboards.json
            git commit -m "chore: update from llm-stats.com"
            git push
          else
            echo "No changes"
          fi
