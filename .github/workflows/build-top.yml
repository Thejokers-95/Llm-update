name: Build from AI Leaderboards page (scrape & merge JSON)

on:
  schedule:
    - cron: "35 5 * * *"   # tous les jours à 05:35 UTC
  workflow_dispatch:

permissions:
  contents: write

jobs:
  scrape:
    runs-on: ubuntu-latest
    env:
      # ➜ METS ICI L’URL EXACTE DE TA PAGE "AI Leaderboards"
      LEADERBOARD_URL: https://example.com/ai-leaderboards

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Puppeteer
        run: |
          npm init -y
          npm i puppeteer@22

      - name: Write scraper
        run: |
          cat > scrape_leaderboards.mjs <<'JS'
          import fs from 'node:fs/promises';
          import puppeteer from 'puppeteer';

          const URL = process.env.LEADERBOARD_URL;

          const sleep = (ms)=> new Promise(r=>setTimeout(r,ms));

          // ---------- utils ----------
          function toFloat(x){
            if (x == null) return null;
            const s = String(x).replace(/[, $%]/g,'').trim();
            if (!s || /^[\-–—]$/.test(s)) return null;
            const f = Number(s);
            return Number.isFinite(f) ? f : null;
          }
          function parseTokens(x){
            if (x == null) return null;
            let s = String(x).toLowerCase().replace(/[, ]/g,'').replace('tokens','');
            if (!s || /^[\-–—]$/.test(s)) return null;
            if (/^\d+$/.test(s)) return Number(s);
            let m = s.match(/^([\d.]+)m$/); if (m) return Math.round(Number(m[1])*1_000_000);
            m = s.match(/^([\d.]+)k$/);     if (m) return Math.round(Number(m[1])*1_000);
            return null;
          }
          function fmtTokens(n){
            if (n >= 1_000_000) return `${(n/1_000_000).toFixed(1)}M tokens`;
            if (n >= 1_000)     return `${Math.round(n/1000)}K tokens`;
            return `${Math.round(n)} tokens`;
          }

          // Cherche une carte par titre (h2/h3) avec un regex
          async function grabCardText(page, regex){
            return page.evaluate((reSrc)=>{
              const re = new RegExp(reSrc, 'i');
              const hs = [...document.querySelectorAll('h2, h3')];
              const h = hs.find(x => re.test(x.innerText.trim()));
              if (!h) return null;
              // on remonte jusqu'au conteneur de section (ou on prend le parent direct)
              let node = h;
              for (let i=0;i<5 && node && node.tagName !== 'SECTION'; i++) node = node.parentElement;
              node = node || h.parentElement;
              return node ? node.innerText : null;
            }, regex.source);
          }

          // Convertit le texte brut de la carte en lignes de rangs 1..5
          function parseRankedBlock(blockText, kind){
            // kind: 'score' (code/mmmu/gpqa) | 'value' (ctx/cheap/fast)
            if (!blockText) return [];
            const L = blockText
              .split(/\n+/)
              .map(s=>s.replace(/\s+/g,' ').trim())
              .filter(Boolean);

            // Repère les index des rangs (lignes = "1", "2", ...)
            const rankIdx = [];
            for (let i=0;i<L.length;i++){
              if (/^[1-5]$/.test(L[i])) rankIdx.push(i);
            }
            if (!rankIdx.length) return [];

            // Découpe en 5 segments [rank .. nextRank)
            const rows=[];
            for (let r=0;r<rankIdx.length;r++){
              const start = rankIdx[r];
              const end   = rankIdx[r+1] ?? L.length;
              const seg   = L.slice(start+1, end); // on saute le numéro
              // Heuristique: name = 1ère ligne "alphnum/signes", value = dernier nombre/unité plausible
              let name = seg.find(s => /[A-Za-z0-9]/.test(s)) || '';
              // value: dernier token chiffré compatible
              let valLine = [...seg].reverse().find(s => /(\d[\d\.,]*\s*(?:tokens\/s|tokens|\/\s*1M\s*tokens|%|$))/i.test(s));
              if (!valLine) valLine = seg.find(s => /(\d[\d\.,]*\s*(?:tokens\/s|tokens|\/\s*1M\s*tokens|%|$))/i.test(s));
              let score = null, value = null;
              if (valLine){
                const mPct = valLine.match(/(\d+\.\d+)/);                     // 88.4
                const mTok = valLine.match(/([\d\.,]+)\s*tokens(?:\/s)?/i);    // 10.0M tokens, 639 tokens/s
                const mPer = valLine.match(/\$\s*([\d\.,]+)\s*\/\s*1M/i);      // $0.17 / 1M tokens
                if (kind==='score' && mPct){
                  score = Number(mPct[1]);
                } else if (kind==='value' && (mTok || mPer)){
                  value = mTok ? valLine : `$${Number(mPer[1])} / 1M tokens`;
                }
              }
              if (!name) continue;
              if (kind==='score' && score!=null) rows.push({name, score});
              if (kind==='value' && value)       rows.push({name, value});
              if (rows.length===5) break;
            }
            return rows.slice(0,5);
          }

          (async ()=>{
            const browser = await puppeteer.launch({
              headless: 'new',
              args: ['--no-sandbox','--disable-setuid-sandbox']
            });
            const page = await browser.newPage();
            await page.setViewport({width: 1440, height: 900});
            await page.goto(URL, {waitUntil: 'networkidle2', timeout: 90000});

            // scroll pour charger (au cas où lazy)
            for (let i=0;i<10;i++){ await page.evaluate(()=>window.scrollBy(0, window.innerHeight)); await sleep(300); }

            // Récup des 6 cartes (titres tolérants)
            const codeText   = await grabCardText(page, /(best\s+llm.*code|aider\s+polyglot\s+benchmark)/i);
            const multiText  = await grabCardText(page, /(best\s+multimodal\s+llm|mmmu\s+benchmark)/i);
            const knowText   = await grabCardText(page, /(best\s+llm.*knowledge|gpqa\s+benchmark)/i);
            const ctxText    = await grabCardText(page, /(longest\s+context|max\s+input\s+tokens)/i);
            const cheapText  = await grabCardText(page, /(cheapest\s+api\s+provider|input\s+cost|maverick\s+input\s+cost)/i);
            const fastText   = await grabCardText(page, /(fastest\s+api\s+provider|throughput|maverick\s+throughput)/i);

            const code   = parseRankedBlock(codeText,  'score');
            const multi  = parseRankedBlock(multiText, 'score');
            const know   = parseRankedBlock(knowText,  'score');
            const ctx    = parseRankedBlock(ctxText,   'value');
            const cheap  = parseRankedBlock(cheapText, 'value');
            const fast   = parseRankedBlock(fastText,  'value');

            await browser.close();

            // Merge avec JSON existant
            let existing = {};
            try { existing = JSON.parse(await fs.readFile('top-leaderboards.json','utf8')); } catch {}
            const merged = {
              code:           code.length  ? code  : (existing.code || []),
              multimodal:     multi.length ? multi : (existing.multimodal || []),
              knowledge:      know.length  ? know  : (existing.knowledge || []),
              longest_context:ctx.length   ? ctx   : (existing.longest_context || []),
              cheapest:       cheap.length ? cheap : (existing.cheapest || []),
              fastest:        fast.length  ? fast  : (existing.fastest || []),
            };

            await fs.writeFile('top-leaderboards.json', JSON.stringify(merged, null, 2), 'utf8');
            console.log('Done. Counts:', Object.fromEntries(Object.entries(merged).map(([k,v])=>[k, Array.isArray(v)? v.length : 0])));
          })().catch(e=>{ console.error(e); process.exit(1); });
          JS

      - name: Run scraper
        run: node scrape_leaderboards.mjs

      - name: Commit & push if changed
        run: |
          echo "Changed files (before):"; git status --porcelain || true
          if ! git diff --quiet -- top-leaderboards.json; then
            git config user.name  "leaderboards-bot"
            git config user.email "actions@github.com"
            git add top-leaderboards.json
            git commit -m "chore: update from AI Leaderboards page"
            git push
          else
            echo "No changes"
          fi
